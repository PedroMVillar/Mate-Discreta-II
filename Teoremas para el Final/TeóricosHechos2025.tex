\documentclass[a4paper]{article}

\usepackage{xcolor}
\usepackage[
  nomarginpar,
  top=1in,
  bottom=1in,
  left=1in,
  right=1in
]{geometry} 
\usepackage{amsmath, amssymb}  
\usepackage{algorithm}
\usepackage{algorithmic}

% Espaciado entre párrafos y sin sangría
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

% Contadores de problema y subproblema
\newcounter{problem}
\newcounter{subproblem}[problem]

% Comando \problem (con o sin *)
\makeatletter
\newcommand{\problem}{%
  \@ifstar{\Problem}{\stepcounter{problem}\Problem{\theproblem}}}

\newcommand{\Problem}[1]{%
  \setcounter{problem}{#1}%
  \par
  {\mbox{\textbf{\Large Pregunta #1}}%
  \leaders\hbox{\colorbox{black!20}{\phantom{\Large I}}}\hfill}%
  \hspace{-2em}\colorbox{black!20}{\phantom{\Large I}}%
  \par
}

% Comando \subproblem (con o sin *)
\newcommand{\subproblem}{%
  \@ifstar{\Subproblem}{\stepcounter{subproblem}\Subproblem{\thesubproblem}}}

\newcommand{\Subproblem}[1]{%
  \setcounter{subproblem}{#1}%
  \par\vspace{0.5em}
  {\colorbox{black!10}{\makebox[\dimexpr\linewidth-2\fboxsep]{%
    \textbf{\large Solución}%
  }}}\par
}
\makeatother

\begin{document}

\problem
¿Cuál es la complejidad del algoritmo de Edmonds-Karp? Probarlo. (\textsc{Nota: en la prueba se definen unas distancias, y se prueba que esas distancias no disminuyen en pasos sucesivos de EK. Ud. puede usar esto sin necesidad de probarlo})

\subproblem
Completar prueba

\problem   

Probar que si, dados vértices \(x, z\) y flujo \(f\), definimos la distancia relativa a \(f\) como la longitud del menor \(f\)-camino aumentante entre \(x\) y \(z\) (si existe), o infinito si no existe, o 0 si \(x = z\), denotándola como \(d_f(x, z)\), y definimos \(d_k(x) = d_{f_k}(s, x)\), donde \(f_k\) es el \(k\)-ésimo flujo en una corrida de Edmonds-Karp, entonces \(d_k(x) \leq d_{k+1}(x)\).

\subproblem
Completar prueba

\problem
Probar que si, dados vértices \(x, z\) y flujo \(f\), definimos la distancia relativa a \(f\) como la longitud del menor \(f\)-camino aumentante entre \(x\) y \(z\) (si existe), o infinito si no existe, o 0 si \(x = z\), denotándola como \(d_f(x, z)\), y definimos \(b_k(x) = d_{f_k}(x, t)\), donde \(f_k\) es el \(k\)-ésimo flujo en una corrida de Edmonds-Karp, entonces \(b_k(x) \leq b_{k+1}(x)\).  
\textit{(Este teorema solo se tomará a partir de diciembre 2025).}

\subproblem
Completar prueba

\problem
¿Cuál es la complejidad del algoritmo de Dinic? Probarla en ambas versiones: Dinitz original y Dinic-Even.  
\textit{(No hace falta probar que la distancia en redes auxiliares sucesivos aumenta).}

\subproblem
Completar prueba

\problem
¿Cuál es la complejidad del algoritmo de Wave? Probarla.  
\textit{(No hace falta probar que la distancia en redes auxiliares sucesivos aumenta).}

\subproblem
Completar prueba

\problem
Probar que la distancia en redes auxiliares sucesivos aumenta.  
\textit{(Este teorema solo se tomará a partir de diciembre 2025).}

\subproblem
Completar prueba

\problem
Probar que si \(f\) es un flujo maximal, entonces existe un corte \(S\) tal que \(v(f) = \text{cap}(S)\).  
\textit{(Puede usar sin necesidad de probarlo que si \(f\) es flujo y \(S\) es corte, entonces \(v(f) = f(S, \bar{S}) - f(\bar{S}, S)\)).}

\subproblem
Definamos
$$
S=\{s\} \cup\{x \in V: \text { exista un } f \text {-camino aumentante desde } s \text { a } x\}
$$

\begin{itemize}
    \item Como $f$ es maximal entonces no existen $f$-caminos aumentantes desde $s$ a $t$ pues si existiese un tal $f$-camino aumentante, podriamos mandar un $\varepsilon>0$ a través de el, obteniendo un flujo $f^{*}$ tal que $v\left(f^{*}\right)=v(f)+\varepsilon>v(f)$ lo cual contradice que $f$ sea maximal. Por lo tanto, como no existen $f$-caminos aumentantes desde $s$ a $t$ entonces $t \notin S$.
    \item Como $s \in S$ y  $t \notin S$, entonces $S$ \textbf{es un corte}.
\end{itemize}

Observemos que en el resto de la prueba no usaremos que $f$ es maximal, solo que es flujo y que $S$ es corte. Es decir, la prueba valdría para cualquier $f$ tal que el $S$ definido sea un corte. Esto será importante luego.

Como $f$ es flujo y $S$ es corte, entonces $v(f)=f(S, \bar{S})-f(\bar{S}, S)$. Calculemos $f(S, \bar{S})$ y $f(\bar{S}, S)$.

\begin{enumerate}
    \item Cálculo de $f(S, \bar{S})$:
    $$
    f(S, \bar{S})=\sum_{x, y} f(\overrightarrow{x y})[x \in S][y \notin S][x y \in E]
    $$
    Consideremos un par $x, y$ de los que aparecen en esa suma. Como $x \in S$, entonces existe un $f$-camino aumentante entre $s$ y $x$, digamos $s=$ $x_{0}, x_{1}, \ldots, x_{r}=x$. Pero como $y \notin S$, entonces no existe ningún $f$-camino aumentante entre $s$ e $y$. En particular, el camino
    $$
    s=x_{0}, x_{1}, \ldots, x_{r}=x, y
    $$
    \textbf{no es un $f$-camino aumentante}. Pero $\overrightarrow{x y} \in E$, asi \underline{que debería poder serlo}.
    
    ¿Por qué $s=x_{0}, x_{1}, \ldots, x_{r}=x, y$ no es un $f$-camino aumentante a pesar de que $s=x_{0}, x_{1}, \ldots, x_{r}=x$ si lo es y $\overrightarrow{x y}$ existe? La única razón por la cual no es un $f$-camino aumentante es porque no podemos usar el lado $\overrightarrow{x y}$ por estar saturado, es decir:
    $$
    f(\overrightarrow{x y})=c(\overrightarrow{x y})
    $$
    Esto es cierto para cualesquiera $x, y$ que aparezcan en esa suma. Entonces:
    $$
    \begin{aligned}
    f(S, \bar{S}) & =\sum_{x, y} f(\overrightarrow{x y})[x \in S][y \notin S][x y \in E] \\
    & =\sum_{x, y} c(\overrightarrow{x y})[x \in S][y \notin S][x y \in E] \\
    & =c(S, \bar{S})=\operatorname{cap}(S)
    \end{aligned}
    $$
    \item Cálculo de $f(\bar{S}, S)$:
    $$
    f(\bar{S}, S)=\sum_{x, y} f(\overrightarrow{x y})[x \notin S][y \in S][x y \in E]
    $$
    Consideremos un par $x, y$ de los que aparecen en esa suma. Como $y \in S$, entonces existe un $f$-camino aumentante entre $s$ e $y$, digamos $s=x_{0}, x_{1}, \ldots, x_{r}=y$. Pero como $x \notin S$, entonces no existe un $f$-camino aumentante entre $s$ y $x$. En particular
    $$
    s=x_{0}, x_{1}, \ldots, x_{r}=y, x
    $$
    NO ES un $f$-camino aumentante. Pero $\overrightarrow{x y} \in E$, asi que PODRIA serlo, usando $y, x$ como lado backward.

    ¿Porqué $s=x_{0}, x_{1}, \ldots, x_{r}=y, x$ no es un $f$-camino aumentante a pesar de que $s=x_{0}, x_{1}, \ldots, x_{r}=y$ si lo es y $\overrightarrow{x y}$ existe? La única razón es que no podemos usarlo como lado backward por estar vacio, es decir, que $f(\overrightarrow{x y})=0$.

    Esto es cierto para cualesquiera $x, y$ que aparezcan en esa suma. Entonces:

    $$
    \begin{aligned}
    f(\bar{S}, S) & =\sum_{x, y} f(\overrightarrow{x y})[x \notin S][y \in S][x y \in E] \\
    & =\sum_{x, y} 0[x \notin S][y \in S][x y \in E] \\
    & =0
    \end{aligned}
    $$
\end{enumerate}
Entonces probamos que para este $S$:
\begin{itemize}
    \item $f(S, \bar{S})=\operatorname{cap}(S)$
    \item $f(\bar{S}, S)=0$
\end{itemize}
Por lo tanto
$$
\begin{aligned}
v(f) & =f(S, \bar{S})-f(\bar{S}, S) \\
& = \operatorname{cap}(S)-0=\operatorname{cap}(S)
\end{aligned}
$$

\problem
Probar que si \(G\) es conexo y no regular, entonces \(\chi(G) \leq \Delta(G)\).

\subproblem
Completar prueba

\problem
Probar que 2-COLOR es polinomial.

\subproblem
Para probar esto, vamos a dar un algoritmo, que cumpla lo siguiente:
\begin{enumerate}
    \item Resuelve el problema de $2$-color.
    \item Corre en tiempo polinomial.
\end{enumerate}

\begin{center}
    La idea es dar primero el algoritmo, luego probar que es polinomial y por último en la \texttt{correctitud}, probar que el algoritmo da respuestas correctas, es decir, funciona.
\end{center}

Antes de comenzar con la prueba, vamos a dar una observación que nos será útil mas adelante:
\begin{itemize}
    \item \textbf{$\chi(G) \leq 2 \iff \chi(C) \leq 2 \quad \forall c.c \in C$ del grafo $G$, es decir, si cada componente conexa del grafo tiene número cromático menor o igual a $2$, entonces el grafo en sí también lo tiene.}
\end{itemize}
\textbf{[-]} Para resolver el problema de $2$-color, vamos a usar el algoritmo de BFS, que nos permite colorear un grafo de manera eficiente. La idea es la siguiente:
\begin{itemize}
    \item Tomo un vértice $x$ cualquiera en un grafo conexo $G$.
    \item Construyo un árbol generador $T$ de $G$ usando BFS con raíz en $x$.
    \item Ejecutar BFS desde $x$ y determinar el nivel de cada vértice $z$.
    \item Luego asigna los colores según el nivel de los vértices, si el nivel es impar, asigno color $1$, si es par, asigno color $2$.
    \item Por último verifico que no haya aristas que conecten vértices del mismo color, si las hay, entonces el grafo no es $2$-coloreable.
\end{itemize}
\begin{algorithm}
    \caption{Verificar si un grafo es bipartito (2-color)}
    \begin{algorithmic}[1]
        \STATE \textbf{Entrada:} Grafo $G = (V, E)$ conexo
        \STATE \textbf{Salida:} "Sí" si $G$ es bipartito, "No" en caso contrario
        \STATE Seleccionar un vértice inicial $x \in V(G)$
        \STATE Construir un árbol generador $T$ de $G$ usando BFS con raíz en $x$
        \STATE Ejecutar BFS desde $x$ y determinar el nivel de cada vértice $z$
        \FOR{cada vértice $z \in V(G)$}
            \IF{nivel de $T(z)$ es impar}
                \STATE Asignar $c(z) \gets 1$
            \ELSE
                \STATE Asignar $c(z) \gets 2$
            \ENDIF
        \ENDFOR
        \FOR{cada arista $(u, v) \in E(G)$}
            \IF{$c(u) = c(v)$}
                \STATE \textbf{Retornar} "No" \COMMENT{El grafo no es bipartito}
            \ENDIF
        \ENDFOR
        \STATE \textbf{Retornar} "Sí" \COMMENT{El grafo es bipartito}
    \end{algorithmic}
\end{algorithm}
\textbf{[2.]} Ahora tenemos que probar la complejidad, como ya sabemos el colorear es gratis, el peso de complejidad recae en el BFS y en el chequeo de las aristas, ambos corren en tiempo $O(m)$ donde $m$ es la cantidad de aristas, por lo tanto, el algoritmo corre en tiempo polinomial.

Ahora bien, si el algoritmo anterior devuelve \textbf{Sí}, es porque el coloreo es propio, y por lo tanto $\chi(G) \leq 2$. En caso contrario, $\chi(G) \geq 3$.

Para probar esto, vamos a ver que el grafo $G$ \textbf{tiene un ciclo impar}. Para comenzar, voy a plantear la estrategia de la demostración:

\textbf{[1]} Por hipótesis, tenemos que el coloreo del \textit{ciclo for} de nuestro algoritmo \textbf{no es propio}. Esto quiere decir que existe una arista $zv \in V(G)$ tal que $c(z) = c(v)$, en este dato vamos a basar la demostración.

\begin{enumerate}
    \item Considerar el spanning tree $T$ de $G$ generado a partir de un vértice $x$.
    \item Analizar los caminos únicos de $x$ a $z$ y $v$.
    \item Usar la arista $zv$ para construir un ciclo impar.
    \item Probar que el ciclo es impar.
\end{enumerate}

Sea $T$ el spanning tree con raíz $x$. Como $T$ es un árbol, hay un único camino desde $x$ a cualquier otro vértice.
\begin{itemize}
    \item \textbf{Camino de $x$ a $z$ en $T$}: $xz_1z_2 \ldots z_j $ y el nivel de $z$ es $j$.
    \item \textbf{Camino de $x$ a $v$}: $xv_1v_2 \ldots v_i$ y el nivel de $v$ es $i$.
\end{itemize}

Como el coloreo no es propio, entonces $c(z) = c(v)$, lo que implica que ambos son pares o ambos son impares, por lo tanto \textbf{la suma de los niveles es par} (i+j es par). 

Dado que ambos caminos empiezan desde el mismo punto $x$ y terminan en distintos puntos $z$ y $v$, en algún punto se separan en $T$, sea $w$ el último vértice común de ambos caminos, de forma tal que:

\begin{equation*}
    z_0=v_0, \, z_1=v_1, \ldots, z_p=v_p = w \, 
\end{equation*}

Teniendo en cuenta que $xv$ es un lado de $G$ y que $z_k = z$ y $v_j = v$, entonces en $G$ tenemos el ciclo:
\begin{equation*}
    C = w\underbrace{z_{p+1}z_{p+2} \ldots z_{k-1}z}_{k-p \, \, \, \text{vértices}}\underbrace{vv_{j-1}\ldots v_{p+1}}_{j-p \, \, \, \text{vértices}} w
\end{equation*}
en total $C$ tiene $1+k-p+j-p$ vértices, es decir, $k+j-2p+1$ vértices. Como $i+j$ es par, entonces $k+j-2p+1$ es impar, por lo tanto $C$ es un ciclo impar.

\problem
Enunciar y probar el Teorema de Hall.

\subproblem
Completar prueba

\problem
Enunciar y probar el teorema del matrimonio de Kőnig.

\subproblem
Completar prueba

\problem
Probar que si \(G\) es bipartito entonces \(\chi'(G) = \Delta(G)\).  
\textit{(Este teorema solo se tomará a partir de diciembre 2025).}

\subproblem
Completar prueba

\problem
Demostrar las complejidades \(O(n^4)\) y \(O(n^3)\) del algoritmo Húngaro.  
\textit{(Solo a partir de diciembre 2025).}

\subproblem
Completar prueba

\problem
Enunciar el teorema de la cota de Hamming y probarlo.

\subproblem
Completar prueba

\problem
Probar que si \(H\) es matriz de chequeo de \(C\), entonces:  
\[
\delta(C) = \min \{ j \mid \exists \text{ un conjunto de } j \text{ columnas LD de } H \}
\]  
(LD significa “linealmente dependiente”).

\subproblem
Completar prueba


\problem
Sea \(C\) un código cíclico de dimensión \(k\) y longitud \(n\), y sea \(g(x)\) su polinomio generador. Probar que:  

\begin{itemize}
    \item[i)] \(C\) está formado por los múltiplos de \(g(x)\) de grado menor que \(n\).
    \item[ii)] $ C = \{ v(x) \cdot g(x) : v(x) \text{ es un polinomio cualquiera} \} $
    \item[iii)] \(gr(g(x)) = n - k\)
    \item[iv)] \(g(x)\) divide a \(1 + x^n\)
\end{itemize}

\subproblem
Completar prueba

\problem
Probar que 3SAT es NP-completo.

\subproblem
Completar prueba

\problem
Probar que 3-COLOR es NP-completo.

\subproblem
Completar prueba

\problem
Probar que Matrimonio3D (matrimonio trisexual) es NP-completo.

\subproblem
Completar prueba


\end{document}
